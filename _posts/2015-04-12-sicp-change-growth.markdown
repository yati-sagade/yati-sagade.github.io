---

layout: post

title: SICP Exercise 1.14

---

Given a set of coin denominations <span>$\mathbb{C}$</span> of size <span>$n$</span>,
in how many ways can an amount <span>$A$</span> be changed using the coin
denominations in <span>$\mathbb{C}$</span>?

A fairly straightforward solution to this is as follows, using the set of 5
coin denominations, <span>$ \left( 1,5,10,25,50 \right) $</span>.


    (define (count-change amount)
      (cc amount 5))

    (define (nth xs n)
      (first (drop xs n)))

    (define (denom n)
      (nth '(1 5 10 25 50) (- n 1)))

    (define (cc amount kinds-of-coins)
      (cond ((= amount 0) 1)
            ((or (= kinds-of-coins 0)
                 (< amount 0)) 0)
            (else (+ (cc amount (- kinds-of-coins 1))
                     (cc (- amount
                            (denom kinds-of-coins))
                         kinds-of-coins)))))

Drawing the call-tree of `(count-change 11)` is straightforward using the
substitution method. The later part of Exercise 1.14 of [SICP][1] asks you to
find the orders of growth for the space and time consumed by the procedure
`cc`.

Space complexity
------------------

The space consumed by the recursive process generated by `cc` is going to be
proportional to the maximum height of the recursion tree corresponding to an
instance of `cc`, since at any given point in the recursive process, we must
only keep track of the trail of nodes that leads to the root of the tree.

The maximum height of the call tree, for relatively larger amounts
<span>$n$</span>, is going to be dominated by the subtree that contains
successive recursive calls with the amount decreased by 1. Clearly, this means
the maximum height is going to be linear in the amount <span>$n$</span>, or
<span>$\Theta \left(n\right)$</span>.


Time complexity
-----------------

Let us start with the call tree for changing some amount <span>$n$</span>, with
just 1 kind of coin, i.e., the call tree for `(cc n 1)`:

<img src="/assets/cc_1.jpg" height="30%" width="30%" alt="Call tree for (n, 1)" />

We are only allowed here to use one kind of coin, with value <span>$\mathbb{C}_{1} = 1$</span>.

The red nodes are terminal nodes that yield <span>$0$</span>, the green node
is a terminal node that yields <span>$1$</span> (corresponding to the first
condition in the code for `cc`). Each nonterminal node spawns two calls to
`cc`, one (on the left) with the same amount, but fewer kinds of coins, and
the other (on the right) with the amount reduced by 1 and equal kinds of coins.

Excluding the root, each level has exactly <span>$2$</span> nodes, and there
are <span>$n$</span> such levels. This means, the number of `cc` calls
generated by a single `(cc n 1)` call (including the original call) is:

<div>$$
T\left(n,1\right) = 2n + 1 = \Theta \left(n\right)
$$</div>

Next, we will look at the call tree of `(cc n 2)` to calculate
<span>$T\left(n,2\right)$</span>:

<img src="/assets/cc_2.jpg" height="30%" width="30%" alt="Call tree for (n, 1)" />

Here, we are allowed to use two denominations of coins, viz.
<span>$\mathbb{C}_{2} = 5$</span> and <span>$\mathbb{C}_{1} = 1$</span>.

Each black node spawns a `(cc m 1)` subtree (blue), which we've already
analyzed, and a `(cc (- m 5) 2)` subtree. The node colored in red and green is
a terminal node, but yields <span>$0$</span> if the amount is less than zero
and <span>$1$</span> if the amount is exactly zero. I've denoted this final
amount as <span>$\epsilon$</span>, which can be <span>$\le0$</span>.

Excluding the root and and the last level in this tree which contains the
red-green terminal node, there will be exactly <span>$\lfloor {\frac {n} {5}
} \rfloor$</span> levels. Now each of these levels contains a call to `(cc
m 1)` (the blue nodes), each of which, in turn, is
<span>$\Theta\left(n\right)$</span> in time. So each of these levels contains
<span>$T\left(n,1\right) + 1$</span> calls to `cc`. Therefore, the total number of
nodes (including the terminal node and the root) in the call tree for `(cc
n 2)` is:

<div>$$
T\left(n,2\right) = \lfloor {\frac {n} {5} } \rfloor \left( T\left(n,1\right) + 1\right) + 2 = \lfloor {\frac {n} {5} } \rfloor \left( 2n + 2 \right) + 2 = \Theta\left(n^2\right)
$$</div>

Moving ahead, let's take a look at the call tree of `(cc n 3)`, i.e., we are
now allowed to use three denominations of coins, the new addition being
<span>$\mathbb{C}_{3} = 10$</span>:

<img src="/assets/cc_3.jpg" height="30%" width="30%" alt="Call tree for (n, 1)" />


Here also, we see, similar to the previous case, that the total number of calls
to `cc` will be

<div>$$
T\left(n,3\right) = \lfloor {\frac {n} {10} } \rfloor \left( T\left(n,2\right) + 1 \right) + 2 = \lfloor {\frac {n} {10} } \rfloor \times \Theta\left(n^2\right) + 2 = \Theta\left(n^3\right)
$$</div>


We can see a pattern here. For some <span>$k$</span>, <span>$k \gt 1$</span>,
we have,

<div>$$
T\left(n,k\right) = \lfloor {\frac {n} { \mathbb{C}_{k} } } \rfloor \left( T\left(n, k-1\right) + 1 \right) + 2
$$</div>

Here, <span>$\mathbb{C}_{k}$</span> is the <span>$k^{th}$<span> coin denomination. We can
expand this further:

<div>$$
T\left(n,k\right)
= \lfloor {\frac {n} { \mathbb{C}_{k} } } \rfloor \left( T\left(n, k-1\right) + 1 \right) + 2
= \lfloor {\frac {n} { \mathbb{C}_{k} } } \rfloor
\left( \lfloor {\frac {n} { \mathbb{C}_{k-1} }  } \rfloor
\left(... \lfloor \frac {n} { \mathbb{C}_{2} } \rfloor \left(2n+1\right) ...\right)
\right) + 2
= \Theta\left(n^k\right)
$$</div>

Conclusion
-----------
In the preceding analysis of the recursive process generated by `cc`, we see
that although it is an elegant and straighforward way of solving the problem,
it is not particularly efficient in time and grows exponentially with the
number of allowed denominations of coins, and polynomially with the amount to
be changed when the number of denominations is fixed. Note that the actual
values of the coin denominations have no effect on the order of growth of this
process.


[1]: https://mitpress.mit.edu/sicp/
